// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notas.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_notas_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_notas_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_notas_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_notas_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_notas_2eproto;
namespace gerencia_notas {
class AdicionaNotaRequest;
struct AdicionaNotaRequestDefaultTypeInternal;
extern AdicionaNotaRequestDefaultTypeInternal _AdicionaNotaRequest_default_instance_;
class AlunoDisciplinaRequest;
struct AlunoDisciplinaRequestDefaultTypeInternal;
extern AlunoDisciplinaRequestDefaultTypeInternal _AlunoDisciplinaRequest_default_instance_;
class AlunoRequest;
struct AlunoRequestDefaultTypeInternal;
extern AlunoRequestDefaultTypeInternal _AlunoRequest_default_instance_;
class ConsultaNotaResponse;
struct ConsultaNotaResponseDefaultTypeInternal;
extern ConsultaNotaResponseDefaultTypeInternal _ConsultaNotaResponse_default_instance_;
class MediaResponse;
struct MediaResponseDefaultTypeInternal;
extern MediaResponseDefaultTypeInternal _MediaResponse_default_instance_;
class Nota;
struct NotaDefaultTypeInternal;
extern NotaDefaultTypeInternal _Nota_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
}  // namespace gerencia_notas
PROTOBUF_NAMESPACE_OPEN
template<> ::gerencia_notas::AdicionaNotaRequest* Arena::CreateMaybeMessage<::gerencia_notas::AdicionaNotaRequest>(Arena*);
template<> ::gerencia_notas::AlunoDisciplinaRequest* Arena::CreateMaybeMessage<::gerencia_notas::AlunoDisciplinaRequest>(Arena*);
template<> ::gerencia_notas::AlunoRequest* Arena::CreateMaybeMessage<::gerencia_notas::AlunoRequest>(Arena*);
template<> ::gerencia_notas::ConsultaNotaResponse* Arena::CreateMaybeMessage<::gerencia_notas::ConsultaNotaResponse>(Arena*);
template<> ::gerencia_notas::MediaResponse* Arena::CreateMaybeMessage<::gerencia_notas::MediaResponse>(Arena*);
template<> ::gerencia_notas::Nota* Arena::CreateMaybeMessage<::gerencia_notas::Nota>(Arena*);
template<> ::gerencia_notas::StatusResponse* Arena::CreateMaybeMessage<::gerencia_notas::StatusResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gerencia_notas {

// ===================================================================

class Nota final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gerencia_notas.Nota) */ {
 public:
  inline Nota() : Nota(nullptr) {}
  ~Nota() override;
  explicit PROTOBUF_CONSTEXPR Nota(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Nota(const Nota& from);
  Nota(Nota&& from) noexcept
    : Nota() {
    *this = ::std::move(from);
  }

  inline Nota& operator=(const Nota& from) {
    CopyFrom(from);
    return *this;
  }
  inline Nota& operator=(Nota&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Nota& default_instance() {
    return *internal_default_instance();
  }
  static inline const Nota* internal_default_instance() {
    return reinterpret_cast<const Nota*>(
               &_Nota_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Nota& a, Nota& b) {
    a.Swap(&b);
  }
  inline void Swap(Nota* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Nota* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Nota* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Nota>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Nota& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Nota& from) {
    Nota::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Nota* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gerencia_notas.Nota";
  }
  protected:
  explicit Nota(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaFieldNumber = 1,
    kCodDisciplinaFieldNumber = 2,
    kAnoFieldNumber = 3,
    kSemestreFieldNumber = 4,
    kNotaFieldNumber = 5,
  };
  // string ra = 1;
  void clear_ra();
  const std::string& ra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ra();
  PROTOBUF_NODISCARD std::string* release_ra();
  void set_allocated_ra(std::string* ra);
  private:
  const std::string& _internal_ra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ra(const std::string& value);
  std::string* _internal_mutable_ra();
  public:

  // string cod_disciplina = 2;
  void clear_cod_disciplina();
  const std::string& cod_disciplina() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cod_disciplina(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cod_disciplina();
  PROTOBUF_NODISCARD std::string* release_cod_disciplina();
  void set_allocated_cod_disciplina(std::string* cod_disciplina);
  private:
  const std::string& _internal_cod_disciplina() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cod_disciplina(const std::string& value);
  std::string* _internal_mutable_cod_disciplina();
  public:

  // int32 ano = 3;
  void clear_ano();
  int32_t ano() const;
  void set_ano(int32_t value);
  private:
  int32_t _internal_ano() const;
  void _internal_set_ano(int32_t value);
  public:

  // int32 semestre = 4;
  void clear_semestre();
  int32_t semestre() const;
  void set_semestre(int32_t value);
  private:
  int32_t _internal_semestre() const;
  void _internal_set_semestre(int32_t value);
  public:

  // float nota = 5;
  void clear_nota();
  float nota() const;
  void set_nota(float value);
  private:
  float _internal_nota() const;
  void _internal_set_nota(float value);
  public:

  // @@protoc_insertion_point(class_scope:gerencia_notas.Nota)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ra_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cod_disciplina_;
    int32_t ano_;
    int32_t semestre_;
    float nota_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notas_2eproto;
};
// -------------------------------------------------------------------

class ConsultaNotaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gerencia_notas.ConsultaNotaResponse) */ {
 public:
  inline ConsultaNotaResponse() : ConsultaNotaResponse(nullptr) {}
  ~ConsultaNotaResponse() override;
  explicit PROTOBUF_CONSTEXPR ConsultaNotaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsultaNotaResponse(const ConsultaNotaResponse& from);
  ConsultaNotaResponse(ConsultaNotaResponse&& from) noexcept
    : ConsultaNotaResponse() {
    *this = ::std::move(from);
  }

  inline ConsultaNotaResponse& operator=(const ConsultaNotaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsultaNotaResponse& operator=(ConsultaNotaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsultaNotaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsultaNotaResponse* internal_default_instance() {
    return reinterpret_cast<const ConsultaNotaResponse*>(
               &_ConsultaNotaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConsultaNotaResponse& a, ConsultaNotaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsultaNotaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsultaNotaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsultaNotaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConsultaNotaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsultaNotaResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConsultaNotaResponse& from) {
    ConsultaNotaResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsultaNotaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gerencia_notas.ConsultaNotaResponse";
  }
  protected:
  explicit ConsultaNotaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgErroFieldNumber = 3,
    kNotaFieldNumber = 2,
    kSucessoFieldNumber = 1,
  };
  // string msg_erro = 3;
  void clear_msg_erro();
  const std::string& msg_erro() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_erro(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_erro();
  PROTOBUF_NODISCARD std::string* release_msg_erro();
  void set_allocated_msg_erro(std::string* msg_erro);
  private:
  const std::string& _internal_msg_erro() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_erro(const std::string& value);
  std::string* _internal_mutable_msg_erro();
  public:

  // .gerencia_notas.Nota nota = 2;
  bool has_nota() const;
  private:
  bool _internal_has_nota() const;
  public:
  void clear_nota();
  const ::gerencia_notas::Nota& nota() const;
  PROTOBUF_NODISCARD ::gerencia_notas::Nota* release_nota();
  ::gerencia_notas::Nota* mutable_nota();
  void set_allocated_nota(::gerencia_notas::Nota* nota);
  private:
  const ::gerencia_notas::Nota& _internal_nota() const;
  ::gerencia_notas::Nota* _internal_mutable_nota();
  public:
  void unsafe_arena_set_allocated_nota(
      ::gerencia_notas::Nota* nota);
  ::gerencia_notas::Nota* unsafe_arena_release_nota();

  // bool sucesso = 1;
  void clear_sucesso();
  bool sucesso() const;
  void set_sucesso(bool value);
  private:
  bool _internal_sucesso() const;
  void _internal_set_sucesso(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gerencia_notas.ConsultaNotaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_erro_;
    ::gerencia_notas::Nota* nota_;
    bool sucesso_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notas_2eproto;
};
// -------------------------------------------------------------------

class AlunoDisciplinaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gerencia_notas.AlunoDisciplinaRequest) */ {
 public:
  inline AlunoDisciplinaRequest() : AlunoDisciplinaRequest(nullptr) {}
  ~AlunoDisciplinaRequest() override;
  explicit PROTOBUF_CONSTEXPR AlunoDisciplinaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlunoDisciplinaRequest(const AlunoDisciplinaRequest& from);
  AlunoDisciplinaRequest(AlunoDisciplinaRequest&& from) noexcept
    : AlunoDisciplinaRequest() {
    *this = ::std::move(from);
  }

  inline AlunoDisciplinaRequest& operator=(const AlunoDisciplinaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlunoDisciplinaRequest& operator=(AlunoDisciplinaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlunoDisciplinaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlunoDisciplinaRequest* internal_default_instance() {
    return reinterpret_cast<const AlunoDisciplinaRequest*>(
               &_AlunoDisciplinaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AlunoDisciplinaRequest& a, AlunoDisciplinaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AlunoDisciplinaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlunoDisciplinaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlunoDisciplinaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlunoDisciplinaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlunoDisciplinaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlunoDisciplinaRequest& from) {
    AlunoDisciplinaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlunoDisciplinaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gerencia_notas.AlunoDisciplinaRequest";
  }
  protected:
  explicit AlunoDisciplinaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaFieldNumber = 1,
    kCodDisciplinaFieldNumber = 2,
  };
  // string ra = 1;
  void clear_ra();
  const std::string& ra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ra();
  PROTOBUF_NODISCARD std::string* release_ra();
  void set_allocated_ra(std::string* ra);
  private:
  const std::string& _internal_ra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ra(const std::string& value);
  std::string* _internal_mutable_ra();
  public:

  // string cod_disciplina = 2;
  void clear_cod_disciplina();
  const std::string& cod_disciplina() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cod_disciplina(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cod_disciplina();
  PROTOBUF_NODISCARD std::string* release_cod_disciplina();
  void set_allocated_cod_disciplina(std::string* cod_disciplina);
  private:
  const std::string& _internal_cod_disciplina() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cod_disciplina(const std::string& value);
  std::string* _internal_mutable_cod_disciplina();
  public:

  // @@protoc_insertion_point(class_scope:gerencia_notas.AlunoDisciplinaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ra_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cod_disciplina_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notas_2eproto;
};
// -------------------------------------------------------------------

class AdicionaNotaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gerencia_notas.AdicionaNotaRequest) */ {
 public:
  inline AdicionaNotaRequest() : AdicionaNotaRequest(nullptr) {}
  ~AdicionaNotaRequest() override;
  explicit PROTOBUF_CONSTEXPR AdicionaNotaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdicionaNotaRequest(const AdicionaNotaRequest& from);
  AdicionaNotaRequest(AdicionaNotaRequest&& from) noexcept
    : AdicionaNotaRequest() {
    *this = ::std::move(from);
  }

  inline AdicionaNotaRequest& operator=(const AdicionaNotaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdicionaNotaRequest& operator=(AdicionaNotaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdicionaNotaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdicionaNotaRequest* internal_default_instance() {
    return reinterpret_cast<const AdicionaNotaRequest*>(
               &_AdicionaNotaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AdicionaNotaRequest& a, AdicionaNotaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AdicionaNotaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdicionaNotaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdicionaNotaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdicionaNotaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdicionaNotaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdicionaNotaRequest& from) {
    AdicionaNotaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdicionaNotaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gerencia_notas.AdicionaNotaRequest";
  }
  protected:
  explicit AdicionaNotaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaFieldNumber = 1,
    kCodDisciplinaFieldNumber = 2,
    kAnoFieldNumber = 3,
    kSemestreFieldNumber = 4,
    kNotaFieldNumber = 5,
  };
  // string ra = 1;
  void clear_ra();
  const std::string& ra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ra();
  PROTOBUF_NODISCARD std::string* release_ra();
  void set_allocated_ra(std::string* ra);
  private:
  const std::string& _internal_ra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ra(const std::string& value);
  std::string* _internal_mutable_ra();
  public:

  // string cod_disciplina = 2;
  void clear_cod_disciplina();
  const std::string& cod_disciplina() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cod_disciplina(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cod_disciplina();
  PROTOBUF_NODISCARD std::string* release_cod_disciplina();
  void set_allocated_cod_disciplina(std::string* cod_disciplina);
  private:
  const std::string& _internal_cod_disciplina() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cod_disciplina(const std::string& value);
  std::string* _internal_mutable_cod_disciplina();
  public:

  // int32 ano = 3;
  void clear_ano();
  int32_t ano() const;
  void set_ano(int32_t value);
  private:
  int32_t _internal_ano() const;
  void _internal_set_ano(int32_t value);
  public:

  // int32 semestre = 4;
  void clear_semestre();
  int32_t semestre() const;
  void set_semestre(int32_t value);
  private:
  int32_t _internal_semestre() const;
  void _internal_set_semestre(int32_t value);
  public:

  // float nota = 5;
  void clear_nota();
  float nota() const;
  void set_nota(float value);
  private:
  float _internal_nota() const;
  void _internal_set_nota(float value);
  public:

  // @@protoc_insertion_point(class_scope:gerencia_notas.AdicionaNotaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ra_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cod_disciplina_;
    int32_t ano_;
    int32_t semestre_;
    float nota_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notas_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gerencia_notas.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  explicit PROTOBUF_CONSTEXPR StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gerencia_notas.StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSucessoFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool sucesso = 1;
  void clear_sucesso();
  bool sucesso() const;
  void set_sucesso(bool value);
  private:
  bool _internal_sucesso() const;
  void _internal_set_sucesso(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gerencia_notas.StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool sucesso_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notas_2eproto;
};
// -------------------------------------------------------------------

class AlunoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gerencia_notas.AlunoRequest) */ {
 public:
  inline AlunoRequest() : AlunoRequest(nullptr) {}
  ~AlunoRequest() override;
  explicit PROTOBUF_CONSTEXPR AlunoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlunoRequest(const AlunoRequest& from);
  AlunoRequest(AlunoRequest&& from) noexcept
    : AlunoRequest() {
    *this = ::std::move(from);
  }

  inline AlunoRequest& operator=(const AlunoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlunoRequest& operator=(AlunoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlunoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlunoRequest* internal_default_instance() {
    return reinterpret_cast<const AlunoRequest*>(
               &_AlunoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AlunoRequest& a, AlunoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AlunoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlunoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlunoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlunoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlunoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlunoRequest& from) {
    AlunoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlunoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gerencia_notas.AlunoRequest";
  }
  protected:
  explicit AlunoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaFieldNumber = 1,
  };
  // string ra = 1;
  void clear_ra();
  const std::string& ra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ra();
  PROTOBUF_NODISCARD std::string* release_ra();
  void set_allocated_ra(std::string* ra);
  private:
  const std::string& _internal_ra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ra(const std::string& value);
  std::string* _internal_mutable_ra();
  public:

  // @@protoc_insertion_point(class_scope:gerencia_notas.AlunoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notas_2eproto;
};
// -------------------------------------------------------------------

class MediaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gerencia_notas.MediaResponse) */ {
 public:
  inline MediaResponse() : MediaResponse(nullptr) {}
  ~MediaResponse() override;
  explicit PROTOBUF_CONSTEXPR MediaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaResponse(const MediaResponse& from);
  MediaResponse(MediaResponse&& from) noexcept
    : MediaResponse() {
    *this = ::std::move(from);
  }

  inline MediaResponse& operator=(const MediaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaResponse& operator=(MediaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaResponse* internal_default_instance() {
    return reinterpret_cast<const MediaResponse*>(
               &_MediaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MediaResponse& a, MediaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MediaResponse& from) {
    MediaResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gerencia_notas.MediaResponse";
  }
  protected:
  explicit MediaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgErroFieldNumber = 3,
    kSucessoFieldNumber = 1,
    kMediaFieldNumber = 2,
  };
  // string msg_erro = 3;
  void clear_msg_erro();
  const std::string& msg_erro() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_erro(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_erro();
  PROTOBUF_NODISCARD std::string* release_msg_erro();
  void set_allocated_msg_erro(std::string* msg_erro);
  private:
  const std::string& _internal_msg_erro() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_erro(const std::string& value);
  std::string* _internal_mutable_msg_erro();
  public:

  // bool sucesso = 1;
  void clear_sucesso();
  bool sucesso() const;
  void set_sucesso(bool value);
  private:
  bool _internal_sucesso() const;
  void _internal_set_sucesso(bool value);
  public:

  // float media = 2;
  void clear_media();
  float media() const;
  void set_media(float value);
  private:
  float _internal_media() const;
  void _internal_set_media(float value);
  public:

  // @@protoc_insertion_point(class_scope:gerencia_notas.MediaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_erro_;
    bool sucesso_;
    float media_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notas_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Nota

// string ra = 1;
inline void Nota::clear_ra() {
  _impl_.ra_.ClearToEmpty();
}
inline const std::string& Nota::ra() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.Nota.ra)
  return _internal_ra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Nota::set_ra(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ra_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.Nota.ra)
}
inline std::string* Nota::mutable_ra() {
  std::string* _s = _internal_mutable_ra();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.Nota.ra)
  return _s;
}
inline const std::string& Nota::_internal_ra() const {
  return _impl_.ra_.Get();
}
inline void Nota::_internal_set_ra(const std::string& value) {
  
  _impl_.ra_.Set(value, GetArenaForAllocation());
}
inline std::string* Nota::_internal_mutable_ra() {
  
  return _impl_.ra_.Mutable(GetArenaForAllocation());
}
inline std::string* Nota::release_ra() {
  // @@protoc_insertion_point(field_release:gerencia_notas.Nota.ra)
  return _impl_.ra_.Release();
}
inline void Nota::set_allocated_ra(std::string* ra) {
  if (ra != nullptr) {
    
  } else {
    
  }
  _impl_.ra_.SetAllocated(ra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ra_.IsDefault()) {
    _impl_.ra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.Nota.ra)
}

// string cod_disciplina = 2;
inline void Nota::clear_cod_disciplina() {
  _impl_.cod_disciplina_.ClearToEmpty();
}
inline const std::string& Nota::cod_disciplina() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.Nota.cod_disciplina)
  return _internal_cod_disciplina();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Nota::set_cod_disciplina(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cod_disciplina_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.Nota.cod_disciplina)
}
inline std::string* Nota::mutable_cod_disciplina() {
  std::string* _s = _internal_mutable_cod_disciplina();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.Nota.cod_disciplina)
  return _s;
}
inline const std::string& Nota::_internal_cod_disciplina() const {
  return _impl_.cod_disciplina_.Get();
}
inline void Nota::_internal_set_cod_disciplina(const std::string& value) {
  
  _impl_.cod_disciplina_.Set(value, GetArenaForAllocation());
}
inline std::string* Nota::_internal_mutable_cod_disciplina() {
  
  return _impl_.cod_disciplina_.Mutable(GetArenaForAllocation());
}
inline std::string* Nota::release_cod_disciplina() {
  // @@protoc_insertion_point(field_release:gerencia_notas.Nota.cod_disciplina)
  return _impl_.cod_disciplina_.Release();
}
inline void Nota::set_allocated_cod_disciplina(std::string* cod_disciplina) {
  if (cod_disciplina != nullptr) {
    
  } else {
    
  }
  _impl_.cod_disciplina_.SetAllocated(cod_disciplina, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cod_disciplina_.IsDefault()) {
    _impl_.cod_disciplina_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.Nota.cod_disciplina)
}

// int32 ano = 3;
inline void Nota::clear_ano() {
  _impl_.ano_ = 0;
}
inline int32_t Nota::_internal_ano() const {
  return _impl_.ano_;
}
inline int32_t Nota::ano() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.Nota.ano)
  return _internal_ano();
}
inline void Nota::_internal_set_ano(int32_t value) {
  
  _impl_.ano_ = value;
}
inline void Nota::set_ano(int32_t value) {
  _internal_set_ano(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.Nota.ano)
}

// int32 semestre = 4;
inline void Nota::clear_semestre() {
  _impl_.semestre_ = 0;
}
inline int32_t Nota::_internal_semestre() const {
  return _impl_.semestre_;
}
inline int32_t Nota::semestre() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.Nota.semestre)
  return _internal_semestre();
}
inline void Nota::_internal_set_semestre(int32_t value) {
  
  _impl_.semestre_ = value;
}
inline void Nota::set_semestre(int32_t value) {
  _internal_set_semestre(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.Nota.semestre)
}

// float nota = 5;
inline void Nota::clear_nota() {
  _impl_.nota_ = 0;
}
inline float Nota::_internal_nota() const {
  return _impl_.nota_;
}
inline float Nota::nota() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.Nota.nota)
  return _internal_nota();
}
inline void Nota::_internal_set_nota(float value) {
  
  _impl_.nota_ = value;
}
inline void Nota::set_nota(float value) {
  _internal_set_nota(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.Nota.nota)
}

// -------------------------------------------------------------------

// ConsultaNotaResponse

// bool sucesso = 1;
inline void ConsultaNotaResponse::clear_sucesso() {
  _impl_.sucesso_ = false;
}
inline bool ConsultaNotaResponse::_internal_sucesso() const {
  return _impl_.sucesso_;
}
inline bool ConsultaNotaResponse::sucesso() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.ConsultaNotaResponse.sucesso)
  return _internal_sucesso();
}
inline void ConsultaNotaResponse::_internal_set_sucesso(bool value) {
  
  _impl_.sucesso_ = value;
}
inline void ConsultaNotaResponse::set_sucesso(bool value) {
  _internal_set_sucesso(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.ConsultaNotaResponse.sucesso)
}

// .gerencia_notas.Nota nota = 2;
inline bool ConsultaNotaResponse::_internal_has_nota() const {
  return this != internal_default_instance() && _impl_.nota_ != nullptr;
}
inline bool ConsultaNotaResponse::has_nota() const {
  return _internal_has_nota();
}
inline void ConsultaNotaResponse::clear_nota() {
  if (GetArenaForAllocation() == nullptr && _impl_.nota_ != nullptr) {
    delete _impl_.nota_;
  }
  _impl_.nota_ = nullptr;
}
inline const ::gerencia_notas::Nota& ConsultaNotaResponse::_internal_nota() const {
  const ::gerencia_notas::Nota* p = _impl_.nota_;
  return p != nullptr ? *p : reinterpret_cast<const ::gerencia_notas::Nota&>(
      ::gerencia_notas::_Nota_default_instance_);
}
inline const ::gerencia_notas::Nota& ConsultaNotaResponse::nota() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.ConsultaNotaResponse.nota)
  return _internal_nota();
}
inline void ConsultaNotaResponse::unsafe_arena_set_allocated_nota(
    ::gerencia_notas::Nota* nota) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nota_);
  }
  _impl_.nota_ = nota;
  if (nota) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gerencia_notas.ConsultaNotaResponse.nota)
}
inline ::gerencia_notas::Nota* ConsultaNotaResponse::release_nota() {
  
  ::gerencia_notas::Nota* temp = _impl_.nota_;
  _impl_.nota_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gerencia_notas::Nota* ConsultaNotaResponse::unsafe_arena_release_nota() {
  // @@protoc_insertion_point(field_release:gerencia_notas.ConsultaNotaResponse.nota)
  
  ::gerencia_notas::Nota* temp = _impl_.nota_;
  _impl_.nota_ = nullptr;
  return temp;
}
inline ::gerencia_notas::Nota* ConsultaNotaResponse::_internal_mutable_nota() {
  
  if (_impl_.nota_ == nullptr) {
    auto* p = CreateMaybeMessage<::gerencia_notas::Nota>(GetArenaForAllocation());
    _impl_.nota_ = p;
  }
  return _impl_.nota_;
}
inline ::gerencia_notas::Nota* ConsultaNotaResponse::mutable_nota() {
  ::gerencia_notas::Nota* _msg = _internal_mutable_nota();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.ConsultaNotaResponse.nota)
  return _msg;
}
inline void ConsultaNotaResponse::set_allocated_nota(::gerencia_notas::Nota* nota) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nota_;
  }
  if (nota) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nota);
    if (message_arena != submessage_arena) {
      nota = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nota, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nota_ = nota;
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.ConsultaNotaResponse.nota)
}

// string msg_erro = 3;
inline void ConsultaNotaResponse::clear_msg_erro() {
  _impl_.msg_erro_.ClearToEmpty();
}
inline const std::string& ConsultaNotaResponse::msg_erro() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.ConsultaNotaResponse.msg_erro)
  return _internal_msg_erro();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsultaNotaResponse::set_msg_erro(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_erro_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.ConsultaNotaResponse.msg_erro)
}
inline std::string* ConsultaNotaResponse::mutable_msg_erro() {
  std::string* _s = _internal_mutable_msg_erro();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.ConsultaNotaResponse.msg_erro)
  return _s;
}
inline const std::string& ConsultaNotaResponse::_internal_msg_erro() const {
  return _impl_.msg_erro_.Get();
}
inline void ConsultaNotaResponse::_internal_set_msg_erro(const std::string& value) {
  
  _impl_.msg_erro_.Set(value, GetArenaForAllocation());
}
inline std::string* ConsultaNotaResponse::_internal_mutable_msg_erro() {
  
  return _impl_.msg_erro_.Mutable(GetArenaForAllocation());
}
inline std::string* ConsultaNotaResponse::release_msg_erro() {
  // @@protoc_insertion_point(field_release:gerencia_notas.ConsultaNotaResponse.msg_erro)
  return _impl_.msg_erro_.Release();
}
inline void ConsultaNotaResponse::set_allocated_msg_erro(std::string* msg_erro) {
  if (msg_erro != nullptr) {
    
  } else {
    
  }
  _impl_.msg_erro_.SetAllocated(msg_erro, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_erro_.IsDefault()) {
    _impl_.msg_erro_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.ConsultaNotaResponse.msg_erro)
}

// -------------------------------------------------------------------

// AlunoDisciplinaRequest

// string ra = 1;
inline void AlunoDisciplinaRequest::clear_ra() {
  _impl_.ra_.ClearToEmpty();
}
inline const std::string& AlunoDisciplinaRequest::ra() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.AlunoDisciplinaRequest.ra)
  return _internal_ra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlunoDisciplinaRequest::set_ra(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ra_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.AlunoDisciplinaRequest.ra)
}
inline std::string* AlunoDisciplinaRequest::mutable_ra() {
  std::string* _s = _internal_mutable_ra();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.AlunoDisciplinaRequest.ra)
  return _s;
}
inline const std::string& AlunoDisciplinaRequest::_internal_ra() const {
  return _impl_.ra_.Get();
}
inline void AlunoDisciplinaRequest::_internal_set_ra(const std::string& value) {
  
  _impl_.ra_.Set(value, GetArenaForAllocation());
}
inline std::string* AlunoDisciplinaRequest::_internal_mutable_ra() {
  
  return _impl_.ra_.Mutable(GetArenaForAllocation());
}
inline std::string* AlunoDisciplinaRequest::release_ra() {
  // @@protoc_insertion_point(field_release:gerencia_notas.AlunoDisciplinaRequest.ra)
  return _impl_.ra_.Release();
}
inline void AlunoDisciplinaRequest::set_allocated_ra(std::string* ra) {
  if (ra != nullptr) {
    
  } else {
    
  }
  _impl_.ra_.SetAllocated(ra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ra_.IsDefault()) {
    _impl_.ra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.AlunoDisciplinaRequest.ra)
}

// string cod_disciplina = 2;
inline void AlunoDisciplinaRequest::clear_cod_disciplina() {
  _impl_.cod_disciplina_.ClearToEmpty();
}
inline const std::string& AlunoDisciplinaRequest::cod_disciplina() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.AlunoDisciplinaRequest.cod_disciplina)
  return _internal_cod_disciplina();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlunoDisciplinaRequest::set_cod_disciplina(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cod_disciplina_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.AlunoDisciplinaRequest.cod_disciplina)
}
inline std::string* AlunoDisciplinaRequest::mutable_cod_disciplina() {
  std::string* _s = _internal_mutable_cod_disciplina();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.AlunoDisciplinaRequest.cod_disciplina)
  return _s;
}
inline const std::string& AlunoDisciplinaRequest::_internal_cod_disciplina() const {
  return _impl_.cod_disciplina_.Get();
}
inline void AlunoDisciplinaRequest::_internal_set_cod_disciplina(const std::string& value) {
  
  _impl_.cod_disciplina_.Set(value, GetArenaForAllocation());
}
inline std::string* AlunoDisciplinaRequest::_internal_mutable_cod_disciplina() {
  
  return _impl_.cod_disciplina_.Mutable(GetArenaForAllocation());
}
inline std::string* AlunoDisciplinaRequest::release_cod_disciplina() {
  // @@protoc_insertion_point(field_release:gerencia_notas.AlunoDisciplinaRequest.cod_disciplina)
  return _impl_.cod_disciplina_.Release();
}
inline void AlunoDisciplinaRequest::set_allocated_cod_disciplina(std::string* cod_disciplina) {
  if (cod_disciplina != nullptr) {
    
  } else {
    
  }
  _impl_.cod_disciplina_.SetAllocated(cod_disciplina, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cod_disciplina_.IsDefault()) {
    _impl_.cod_disciplina_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.AlunoDisciplinaRequest.cod_disciplina)
}

// -------------------------------------------------------------------

// AdicionaNotaRequest

// string ra = 1;
inline void AdicionaNotaRequest::clear_ra() {
  _impl_.ra_.ClearToEmpty();
}
inline const std::string& AdicionaNotaRequest::ra() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.AdicionaNotaRequest.ra)
  return _internal_ra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdicionaNotaRequest::set_ra(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ra_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.AdicionaNotaRequest.ra)
}
inline std::string* AdicionaNotaRequest::mutable_ra() {
  std::string* _s = _internal_mutable_ra();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.AdicionaNotaRequest.ra)
  return _s;
}
inline const std::string& AdicionaNotaRequest::_internal_ra() const {
  return _impl_.ra_.Get();
}
inline void AdicionaNotaRequest::_internal_set_ra(const std::string& value) {
  
  _impl_.ra_.Set(value, GetArenaForAllocation());
}
inline std::string* AdicionaNotaRequest::_internal_mutable_ra() {
  
  return _impl_.ra_.Mutable(GetArenaForAllocation());
}
inline std::string* AdicionaNotaRequest::release_ra() {
  // @@protoc_insertion_point(field_release:gerencia_notas.AdicionaNotaRequest.ra)
  return _impl_.ra_.Release();
}
inline void AdicionaNotaRequest::set_allocated_ra(std::string* ra) {
  if (ra != nullptr) {
    
  } else {
    
  }
  _impl_.ra_.SetAllocated(ra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ra_.IsDefault()) {
    _impl_.ra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.AdicionaNotaRequest.ra)
}

// string cod_disciplina = 2;
inline void AdicionaNotaRequest::clear_cod_disciplina() {
  _impl_.cod_disciplina_.ClearToEmpty();
}
inline const std::string& AdicionaNotaRequest::cod_disciplina() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.AdicionaNotaRequest.cod_disciplina)
  return _internal_cod_disciplina();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdicionaNotaRequest::set_cod_disciplina(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cod_disciplina_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.AdicionaNotaRequest.cod_disciplina)
}
inline std::string* AdicionaNotaRequest::mutable_cod_disciplina() {
  std::string* _s = _internal_mutable_cod_disciplina();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.AdicionaNotaRequest.cod_disciplina)
  return _s;
}
inline const std::string& AdicionaNotaRequest::_internal_cod_disciplina() const {
  return _impl_.cod_disciplina_.Get();
}
inline void AdicionaNotaRequest::_internal_set_cod_disciplina(const std::string& value) {
  
  _impl_.cod_disciplina_.Set(value, GetArenaForAllocation());
}
inline std::string* AdicionaNotaRequest::_internal_mutable_cod_disciplina() {
  
  return _impl_.cod_disciplina_.Mutable(GetArenaForAllocation());
}
inline std::string* AdicionaNotaRequest::release_cod_disciplina() {
  // @@protoc_insertion_point(field_release:gerencia_notas.AdicionaNotaRequest.cod_disciplina)
  return _impl_.cod_disciplina_.Release();
}
inline void AdicionaNotaRequest::set_allocated_cod_disciplina(std::string* cod_disciplina) {
  if (cod_disciplina != nullptr) {
    
  } else {
    
  }
  _impl_.cod_disciplina_.SetAllocated(cod_disciplina, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cod_disciplina_.IsDefault()) {
    _impl_.cod_disciplina_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.AdicionaNotaRequest.cod_disciplina)
}

// int32 ano = 3;
inline void AdicionaNotaRequest::clear_ano() {
  _impl_.ano_ = 0;
}
inline int32_t AdicionaNotaRequest::_internal_ano() const {
  return _impl_.ano_;
}
inline int32_t AdicionaNotaRequest::ano() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.AdicionaNotaRequest.ano)
  return _internal_ano();
}
inline void AdicionaNotaRequest::_internal_set_ano(int32_t value) {
  
  _impl_.ano_ = value;
}
inline void AdicionaNotaRequest::set_ano(int32_t value) {
  _internal_set_ano(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.AdicionaNotaRequest.ano)
}

// int32 semestre = 4;
inline void AdicionaNotaRequest::clear_semestre() {
  _impl_.semestre_ = 0;
}
inline int32_t AdicionaNotaRequest::_internal_semestre() const {
  return _impl_.semestre_;
}
inline int32_t AdicionaNotaRequest::semestre() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.AdicionaNotaRequest.semestre)
  return _internal_semestre();
}
inline void AdicionaNotaRequest::_internal_set_semestre(int32_t value) {
  
  _impl_.semestre_ = value;
}
inline void AdicionaNotaRequest::set_semestre(int32_t value) {
  _internal_set_semestre(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.AdicionaNotaRequest.semestre)
}

// float nota = 5;
inline void AdicionaNotaRequest::clear_nota() {
  _impl_.nota_ = 0;
}
inline float AdicionaNotaRequest::_internal_nota() const {
  return _impl_.nota_;
}
inline float AdicionaNotaRequest::nota() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.AdicionaNotaRequest.nota)
  return _internal_nota();
}
inline void AdicionaNotaRequest::_internal_set_nota(float value) {
  
  _impl_.nota_ = value;
}
inline void AdicionaNotaRequest::set_nota(float value) {
  _internal_set_nota(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.AdicionaNotaRequest.nota)
}

// -------------------------------------------------------------------

// StatusResponse

// bool sucesso = 1;
inline void StatusResponse::clear_sucesso() {
  _impl_.sucesso_ = false;
}
inline bool StatusResponse::_internal_sucesso() const {
  return _impl_.sucesso_;
}
inline bool StatusResponse::sucesso() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.StatusResponse.sucesso)
  return _internal_sucesso();
}
inline void StatusResponse::_internal_set_sucesso(bool value) {
  
  _impl_.sucesso_ = value;
}
inline void StatusResponse::set_sucesso(bool value) {
  _internal_set_sucesso(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.StatusResponse.sucesso)
}

// string msg = 2;
inline void StatusResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& StatusResponse::msg() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.StatusResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.StatusResponse.msg)
}
inline std::string* StatusResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.StatusResponse.msg)
  return _s;
}
inline const std::string& StatusResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void StatusResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusResponse::release_msg() {
  // @@protoc_insertion_point(field_release:gerencia_notas.StatusResponse.msg)
  return _impl_.msg_.Release();
}
inline void StatusResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.StatusResponse.msg)
}

// -------------------------------------------------------------------

// AlunoRequest

// string ra = 1;
inline void AlunoRequest::clear_ra() {
  _impl_.ra_.ClearToEmpty();
}
inline const std::string& AlunoRequest::ra() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.AlunoRequest.ra)
  return _internal_ra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlunoRequest::set_ra(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ra_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.AlunoRequest.ra)
}
inline std::string* AlunoRequest::mutable_ra() {
  std::string* _s = _internal_mutable_ra();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.AlunoRequest.ra)
  return _s;
}
inline const std::string& AlunoRequest::_internal_ra() const {
  return _impl_.ra_.Get();
}
inline void AlunoRequest::_internal_set_ra(const std::string& value) {
  
  _impl_.ra_.Set(value, GetArenaForAllocation());
}
inline std::string* AlunoRequest::_internal_mutable_ra() {
  
  return _impl_.ra_.Mutable(GetArenaForAllocation());
}
inline std::string* AlunoRequest::release_ra() {
  // @@protoc_insertion_point(field_release:gerencia_notas.AlunoRequest.ra)
  return _impl_.ra_.Release();
}
inline void AlunoRequest::set_allocated_ra(std::string* ra) {
  if (ra != nullptr) {
    
  } else {
    
  }
  _impl_.ra_.SetAllocated(ra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ra_.IsDefault()) {
    _impl_.ra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.AlunoRequest.ra)
}

// -------------------------------------------------------------------

// MediaResponse

// bool sucesso = 1;
inline void MediaResponse::clear_sucesso() {
  _impl_.sucesso_ = false;
}
inline bool MediaResponse::_internal_sucesso() const {
  return _impl_.sucesso_;
}
inline bool MediaResponse::sucesso() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.MediaResponse.sucesso)
  return _internal_sucesso();
}
inline void MediaResponse::_internal_set_sucesso(bool value) {
  
  _impl_.sucesso_ = value;
}
inline void MediaResponse::set_sucesso(bool value) {
  _internal_set_sucesso(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.MediaResponse.sucesso)
}

// float media = 2;
inline void MediaResponse::clear_media() {
  _impl_.media_ = 0;
}
inline float MediaResponse::_internal_media() const {
  return _impl_.media_;
}
inline float MediaResponse::media() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.MediaResponse.media)
  return _internal_media();
}
inline void MediaResponse::_internal_set_media(float value) {
  
  _impl_.media_ = value;
}
inline void MediaResponse::set_media(float value) {
  _internal_set_media(value);
  // @@protoc_insertion_point(field_set:gerencia_notas.MediaResponse.media)
}

// string msg_erro = 3;
inline void MediaResponse::clear_msg_erro() {
  _impl_.msg_erro_.ClearToEmpty();
}
inline const std::string& MediaResponse::msg_erro() const {
  // @@protoc_insertion_point(field_get:gerencia_notas.MediaResponse.msg_erro)
  return _internal_msg_erro();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MediaResponse::set_msg_erro(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_erro_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gerencia_notas.MediaResponse.msg_erro)
}
inline std::string* MediaResponse::mutable_msg_erro() {
  std::string* _s = _internal_mutable_msg_erro();
  // @@protoc_insertion_point(field_mutable:gerencia_notas.MediaResponse.msg_erro)
  return _s;
}
inline const std::string& MediaResponse::_internal_msg_erro() const {
  return _impl_.msg_erro_.Get();
}
inline void MediaResponse::_internal_set_msg_erro(const std::string& value) {
  
  _impl_.msg_erro_.Set(value, GetArenaForAllocation());
}
inline std::string* MediaResponse::_internal_mutable_msg_erro() {
  
  return _impl_.msg_erro_.Mutable(GetArenaForAllocation());
}
inline std::string* MediaResponse::release_msg_erro() {
  // @@protoc_insertion_point(field_release:gerencia_notas.MediaResponse.msg_erro)
  return _impl_.msg_erro_.Release();
}
inline void MediaResponse::set_allocated_msg_erro(std::string* msg_erro) {
  if (msg_erro != nullptr) {
    
  } else {
    
  }
  _impl_.msg_erro_.SetAllocated(msg_erro, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_erro_.IsDefault()) {
    _impl_.msg_erro_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gerencia_notas.MediaResponse.msg_erro)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gerencia_notas

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_notas_2eproto
